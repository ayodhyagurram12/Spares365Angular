/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define("@nguniversal/builders/src/prerender/index", ["require", "exports", "@angular-devkit/architect", "@angular-devkit/build-angular/src/utils/service-worker", "@angular-devkit/core", "@angular-devkit/core/node", "child_process", "fs", "ora", "path", "@nguniversal/builders/src/prerender/utils"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.execute = void 0;
    const architect_1 = require("@angular-devkit/architect");
    const service_worker_1 = require("@angular-devkit/build-angular/src/utils/service-worker");
    const core_1 = require("@angular-devkit/core");
    const node_1 = require("@angular-devkit/core/node");
    const child_process_1 = require("child_process");
    const fs = require("fs");
    const ora = require("ora");
    const path = require("path");
    const utils_1 = require("@nguniversal/builders/src/prerender/utils");
    /**
     * Schedules the server and browser builds and returns their results if both builds are successful.
     */
    function _scheduleBuilds(options, context) {
        return __awaiter(this, void 0, void 0, function* () {
            const browserTarget = architect_1.targetFromTargetString(options.browserTarget);
            const serverTarget = architect_1.targetFromTargetString(options.serverTarget);
            const browserTargetRun = yield context.scheduleTarget(browserTarget, {
                watch: false,
                serviceWorker: false,
            });
            const serverTargetRun = yield context.scheduleTarget(serverTarget, {
                watch: false,
            });
            try {
                const [browserResult, serverResult] = yield Promise.all([
                    browserTargetRun.result,
                    serverTargetRun.result,
                ]);
                const success = browserResult.success && serverResult.success && browserResult.baseOutputPath !== undefined;
                const error = browserResult.error || serverResult.error;
                return { success, error, browserResult, serverResult };
            }
            catch (e) {
                return { success: false, error: e.message };
            }
            finally {
                yield Promise.all([browserTargetRun.stop(), serverTargetRun.stop()]);
            }
        });
    }
    function _parallelRenderRoutes(shardedRoutes, context, indexHtml, outputPath, indexFile, serverBundlePath) {
        return __awaiter(this, void 0, void 0, function* () {
            const workerFile = path.join(__dirname, 'render.js');
            const childProcesses = shardedRoutes.map(routes => new Promise((resolve, reject) => {
                child_process_1.fork(workerFile, [
                    indexHtml,
                    indexFile,
                    serverBundlePath,
                    outputPath,
                    ...routes,
                ])
                    .on('message', data => {
                    if (data.success) {
                        context.logger.debug(`CREATE ${data.outputIndexPath}`);
                    }
                    else {
                        reject(new Error(`Unable to render ${data.outputIndexPath}.\nError: ${data.error}`));
                    }
                })
                    .on('exit', resolve)
                    .on('error', reject);
            }));
            yield Promise.all(childProcesses);
        });
    }
    /**
     * Renders each route and writes them to
     * <route>/index.html for each output path in the browser result.
     */
    function _renderUniversal(routes, context, browserResult, serverResult, browserOptions, numProcesses) {
        return __awaiter(this, void 0, void 0, function* () {
            const host = new node_1.NodeJsSyncHost();
            const projectName = context.target && context.target.project;
            if (!projectName) {
                throw new Error('The builder requires a target.');
            }
            const root = core_1.normalize(context.workspaceRoot);
            const projectMetadata = yield context.getProjectMetadata(projectName);
            const projectRoot = core_1.resolve(root, core_1.normalize(projectMetadata.root || ''));
            // Users can specify a different base html file e.g. "src/home.html"
            const indexFile = utils_1.getIndexOutputFile(browserOptions);
            // We need to render the routes for each locale from the browser output.
            for (const outputPath of browserResult.outputPaths) {
                const browserIndexInputPath = path.join(outputPath, indexFile);
                const indexHtml = fs.readFileSync(browserIndexInputPath, 'utf8');
                const { baseOutputPath = '' } = serverResult;
                const localeDirectory = path.relative(browserResult.baseOutputPath, outputPath);
                const serverBundlePath = path.join(baseOutputPath, localeDirectory, 'main.js');
                if (!fs.existsSync(serverBundlePath)) {
                    throw new Error(`Could not find the main bundle: ${serverBundlePath}`);
                }
                const shardedRoutes = utils_1.shardArray(routes, numProcesses);
                const spinner = ora(`Prerendering ${routes.length} route(s) to ${outputPath}...`).start();
                try {
                    yield _parallelRenderRoutes(shardedRoutes, context, indexHtml, outputPath, indexFile, serverBundlePath);
                }
                catch (error) {
                    spinner.fail(`Prerendering routes to ${outputPath} failed.`);
                    return { success: false, error: error.message };
                }
                spinner.succeed(`Prerendering routes to ${outputPath} complete.`);
                if (browserOptions.serviceWorker) {
                    spinner.start('Generating service worker...');
                    try {
                        yield service_worker_1.augmentAppWithServiceWorker(host, root, projectRoot, core_1.normalize(outputPath), browserOptions.baseHref || '/', browserOptions.ngswConfigPath);
                    }
                    catch (error) {
                        spinner.fail('Service worker generation failed.');
                        return { success: false, error: error.message };
                    }
                    spinner.succeed('Service worker generation complete.');
                }
            }
            return browserResult;
        });
    }
    /**
     * Builds the browser and server, then renders each route in options.routes
     * and writes them to prerender/<route>/index.html for each output path in
     * the browser result.
     */
    function execute(options, context) {
        return __awaiter(this, void 0, void 0, function* () {
            const browserTarget = architect_1.targetFromTargetString(options.browserTarget);
            const browserOptions = yield context.getTargetOptions(browserTarget);
            const tsConfigPath = typeof browserOptions.tsConfig === 'string' ? browserOptions.tsConfig : undefined;
            const routes = yield utils_1.getRoutes(options, tsConfigPath, context);
            if (!routes.length) {
                throw new Error(`Could not find any routes to prerender.`);
            }
            const result = yield _scheduleBuilds(options, context);
            const { success, error, browserResult, serverResult } = result;
            if (!success || !browserResult || !serverResult) {
                return { success, error };
            }
            return _renderUniversal(routes, context, browserResult, serverResult, browserOptions, options.numProcesses);
        });
    }
    exports.execute = execute;
    exports.default = architect_1.createBuilder(execute);
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9tb2R1bGVzL2J1aWxkZXJzL3NyYy9wcmVyZW5kZXIvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7OztHQU1HOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBRUgseURBQWlIO0lBRWpILDJGQUFxRztJQUNyRywrQ0FBeUU7SUFDekUsb0RBQTJEO0lBQzNELGlEQUFxQztJQUNyQyx5QkFBeUI7SUFDekIsMkJBQTJCO0lBQzNCLDZCQUE2QjtJQUc3QixxRUFBb0U7SUFhcEU7O09BRUc7SUFDSCxTQUFlLGVBQWUsQ0FDNUIsT0FBZ0MsRUFDaEMsT0FBdUI7O1lBRXZCLE1BQU0sYUFBYSxHQUFHLGtDQUFzQixDQUFDLE9BQU8sQ0FBQyxhQUFhLENBQUMsQ0FBQztZQUNwRSxNQUFNLFlBQVksR0FBRyxrQ0FBc0IsQ0FBQyxPQUFPLENBQUMsWUFBWSxDQUFDLENBQUM7WUFFbEUsTUFBTSxnQkFBZ0IsR0FBRyxNQUFNLE9BQU8sQ0FBQyxjQUFjLENBQUMsYUFBYSxFQUFFO2dCQUNuRSxLQUFLLEVBQUUsS0FBSztnQkFDWixhQUFhLEVBQUUsS0FBSzthQUVyQixDQUFDLENBQUM7WUFDSCxNQUFNLGVBQWUsR0FBRyxNQUFNLE9BQU8sQ0FBQyxjQUFjLENBQUMsWUFBWSxFQUFFO2dCQUNqRSxLQUFLLEVBQUUsS0FBSzthQUNiLENBQUMsQ0FBQztZQUVILElBQUk7Z0JBQ0YsTUFBTSxDQUFDLGFBQWEsRUFBRSxZQUFZLENBQUMsR0FBRyxNQUFNLE9BQU8sQ0FBQyxHQUFHLENBQUM7b0JBQ3RELGdCQUFnQixDQUFDLE1BQXVDO29CQUN4RCxlQUFlLENBQUMsTUFBdUM7aUJBQ3hELENBQUMsQ0FBQztnQkFFSCxNQUFNLE9BQU8sR0FDWCxhQUFhLENBQUMsT0FBTyxJQUFJLFlBQVksQ0FBQyxPQUFPLElBQUksYUFBYSxDQUFDLGNBQWMsS0FBSyxTQUFT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QUMseUNBQXlDLENBQUMsQ0FBQzthQUM1RDtZQUVELE1BQU0sTUFBTSxHQUFHLE1BQU0sZUFBZSxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsQ0FBQztZQUN2RCxNQUFNLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxhQUFhLEVBQUUsWUFBWSxFQUFFLEdBQUcsTUFBTSxDQUFDO1lBQy9ELElBQUksQ0FBQyxPQUFPLElBQUksQ0FBQyxhQUFhLElBQUksQ0FBQyxZQUFZLEVBQUU7Z0JBQy9DLE9BQU8sRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFtQixDQUFDO2FBQzVDO1lBRUQsT0FBTyxnQkFBZ0IsQ0FDckIsTUFBTSxFQUNOLE9BQU8sRUFDUCxhQUFhLEVBQ2IsWUFBWSxFQUNaLGNBQWMsRUFDZCxPQUFPLENBQUMsWUFBWSxDQUNyQixDQUFDO1FBQ0osQ0FBQztLQUFBO0lBN0JELDBCQTZCQztJQUVELGtCQUFlLHlCQUFhLENBQUMsT0FBTyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblxuaW1wb3J0IHsgQnVpbGRlckNvbnRleHQsIEJ1aWxkZXJPdXRwdXQsIGNyZWF0ZUJ1aWxkZXIsIHRhcmdldEZyb21UYXJnZXRTdHJpbmcgfSBmcm9tICdAYW5ndWxhci1kZXZraXQvYXJjaGl0ZWN0JztcbmltcG9ydCB7IEJyb3dzZXJCdWlsZGVyT3B0aW9ucyB9IGZyb20gJ0Bhbmd1bGFyLWRldmtpdC9idWlsZC1hbmd1bGFyJztcbmltcG9ydCB7IGF1Z21lbnRBcHBXaXRoU2VydmljZVdvcmtlciB9IGZyb20gJ0Bhbmd1bGFyLWRldmtpdC9idWlsZC1hbmd1bGFyL3NyYy91dGlscy9zZXJ2aWNlLXdvcmtlcic7XG5pbXBvcnQgeyBub3JtYWxpemUsIHJlc29sdmUgYXMgcmVzb2x2ZVBhdGggfSBmcm9tICdAYW5ndWxhci1kZXZraXQvY29yZSc7XG5pbXBvcnQgeyBOb2RlSnNTeW5jSG9zdCB9IGZyb20gJ0Bhbmd1bGFyLWRldmtpdC9jb3JlL25vZGUnO1xuaW1wb3J0IHsgZm9yayB9IGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnO1xuaW1wb3J0ICogYXMgb3JhIGZyb20gJ29yYSc7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xuXG5pbXBvcnQgeyBQcmVyZW5kZXJCdWlsZGVyT3B0aW9ucywgUHJlcmVuZGVyQnVpbGRlck91dHB1dCB9IGZyb20gJy4vbW9kZWxzJztcbmltcG9ydCB7IGdldEluZGV4T3V0cHV0RmlsZSwgZ2V0Um91dGVzLCBzaGFyZEFycmF5IH0gZnJvbSAnLi91dGlscyc7XG5cbnR5cGUgQnVpbGRCdWlsZGVyT3V0cHV0ID0gQnVpbGRlck91dHB1dCAmIHtcbiAgYmFzZU91dHB1dFBhdGg6IHN0cmluZztcbiAgb3V0cHV0UGF0aHM6IHN0cmluZ1tdO1xuICBvdXRwdXRQYXRoOiBzdHJpbmc7XG59O1xuXG50eXBlIFNjaGVkdWxlQnVpbGRzT3V0cHV0ID0gQnVpbGRlck91dHB1dCAmIHtcbiAgc2VydmVyUmVzdWx0PzogQnVpbGRCdWlsZGVyT3V0cHV0O1xuICBicm93c2VyUmVzdWx0PzogQnVpbGRCdWlsZGVyT3V0cHV0O1xufTtcblxuLyoqXG4gKiBTY2hlZHVsZXMgdGhlIHNlcnZlciBhbmQgYnJvd3NlciBidWlsZHMgYW5kIHJldHVybnMgdGhlaXIgcmVzdWx0cyBpZiBib3RoIGJ1aWxkcyBhcmUgc3VjY2Vzc2Z1bC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gX3NjaGVkdWxlQnVpbGRzKFxuICBvcHRpb25zOiBQcmVyZW5kZXJCdWlsZGVyT3B0aW9ucyxcbiAgY29udGV4dDogQnVpbGRlckNvbnRleHRcbik6IFByb21pc2U8U2NoZWR1bGVCdWlsZHNPdXRwdXQ+IHtcbiAgY29uc3QgYnJvd3NlclRhcmdldCA9IHRhcmdldEZyb21UYXJnZXRTdHJpbmcob3B0aW9ucy5icm93c2VyVGFyZ2V0KTtcbiAgY29uc3Qgc2VydmVyVGFyZ2V0ID0gdGFyZ2V0RnJvbVRhcmdldFN0cmluZyhvcHRpb25zLnNlcnZlclRhcmdldCk7XG5cbiAgY29uc3QgYnJvd3NlclRhcmdldFJ1biA9IGF3YWl0IGNvbnRleHQuc2NoZWR1bGVUYXJnZXQoYnJvd3NlclRhcmdldCwge1xuICAgIHdhdGNoOiBmYWxzZSxcbiAgICBzZXJ2aWNlV29ya2VyOiBmYWxzZSxcbiAgICAvLyB0b2RvOiBoYW5kbGUgc2VydmljZSB3b3JrZXIgYXVnbWVudGF0aW9uXG4gIH0pO1xuICBjb25zdCBzZXJ2ZXJUYXJnZXRSdW4gPSBhd2FpdCBjb250ZXh0LnNjaGVkdWxlVGFyZ2V0KHNlcnZlclRhcmdldCwge1xuICAgIHdhdGNoOiBmYWxzZSxcbiAgfSk7XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBbYnJvd3NlclJlc3VsdCwgc2VydmVyUmVzdWx0XSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgIGJyb3dzZXJUYXJnZXRSdW4ucmVzdWx0IGFzIHVua25vd24gYXMgQnVpbGRCdWlsZGVyT3V0cHV0LFxuICAgICAgc2VydmVyVGFyZ2V0UnVuLnJlc3VsdCBhcyB1bmtub3duIGFzIEJ1aWxkQnVpbGRlck91dHB1dCxcbiAgICBdKTtcblxuICAgIGNvbnN0IHN1Y2Nlc3MgPVxuICAgICAgYnJvd3NlclJlc3VsdC5zdWNjZXNzICYmIHNlcnZlclJlc3VsdC5zdWNjZXNzICYmIGJyb3dzZXJSZXN1bHQuYmFzZU91dHB1dFBhdGggIT09IHVuZGVmaW5lZDtcbiAgICBjb25zdCBlcnJvciA9IGJyb3dzZXJSZXN1bHQuZXJyb3IgfHwgc2VydmVyUmVzdWx0LmVycm9yIGFzIHN0cmluZztcblxuICAgIHJldHVybiB7IHN1Y2Nlc3MsIGVycm9yLCBicm93c2VyUmVzdWx0LCBzZXJ2ZXJSZXN1bHQgfTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZS5tZXNzYWdlIH07XG4gIH0gZmluYWxseSB7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoW2Jyb3dzZXJUYXJnZXRSdW4uc3RvcCgpLCBzZXJ2ZXJUYXJnZXRSdW4uc3RvcCgpXSk7XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gX3BhcmFsbGVsUmVuZGVyUm91dGVzKFxuICBzaGFyZGVkUm91dGVzOiBzdHJpbmdbXVtdLFxuICBjb250ZXh0OiBCdWlsZGVyQ29udGV4dCxcbiAgaW5kZXhIdG1sOiBzdHJpbmcsXG4gIG91dHB1dFBhdGg6IHN0cmluZyxcbiAgaW5kZXhGaWxlOiBzdHJpbmcsXG4gIHNlcnZlckJ1bmRsZVBhdGg6IHN0cmluZyxcbik6IFByb21pc2U8dm9pZD4ge1xuICBjb25zdCB3b3JrZXJGaWxlID0gcGF0aC5qb2luKF9fZGlybmFtZSwgJ3JlbmRlci5qcycpO1xuICBjb25zdCBjaGlsZFByb2Nlc3NlcyA9IHNoYXJkZWRSb3V0ZXMubWFwKHJvdXRlcyA9PlxuICAgIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGZvcmsod29ya2VyRmlsZSwgW1xuICAgICAgICBpbmRleEh0bWwsXG4gICAgICAgIGluZGV4RmlsZSxcbiAgICAgICAgc2VydmVyQnVuZGxlUGF0aCxcbiAgICAgICAgb3V0cHV0UGF0aCxcbiAgICAgICAgLi4ucm91dGVzLFxuICAgICAgXSlcbiAgICAgICAgLm9uKCdtZXNzYWdlJywgZGF0YSA9PiB7XG4gICAgICAgICAgaWYgKGRhdGEuc3VjY2Vzcykge1xuICAgICAgICAgICAgY29udGV4dC5sb2dnZXIuZGVidWcoYENSRUFURSAke2RhdGEub3V0cHV0SW5kZXhQYXRofWApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBVbmFibGUgdG8gcmVuZGVyICR7ZGF0YS5vdXRwdXRJbmRleFBhdGh9LlxcbkVycm9yOiAke2RhdGEuZXJyb3J9YCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdleGl0JywgcmVzb2x2ZSlcbiAgICAgICAgLm9uKCdlcnJvcicsIHJlamVjdCk7XG4gICAgfSlcbiAgKTtcblxuICBhd2FpdCBQcm9taXNlLmFsbChjaGlsZFByb2Nlc3Nlcyk7XG59XG5cbi8qKlxuICogUmVuZGVycyBlYWNoIHJvdXRlIGFuZCB3cml0ZXMgdGhlbSB0b1xuICogPHJvdXRlPi9pbmRleC5odG1sIGZvciBlYWNoIG91dHB1dCBwYXRoIGluIHRoZSBicm93c2VyIHJlc3VsdC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gX3JlbmRlclVuaXZlcnNhbChcbiAgcm91dGVzOiBzdHJpbmdbXSxcbiAgY29udGV4dDogQnVpbGRlckNvbnRleHQsXG4gIGJyb3dzZXJSZXN1bHQ6IEJ1aWxkQnVpbGRlck91dHB1dCxcbiAgc2VydmVyUmVzdWx0OiBCdWlsZEJ1aWxkZXJPdXRwdXQsXG4gIGJyb3dzZXJPcHRpb25zOiBCcm93c2VyQnVpbGRlck9wdGlvbnMsXG4gIG51bVByb2Nlc3Nlcz86IG51bWJlcixcbik6IFByb21pc2U8UHJlcmVuZGVyQnVpbGRlck91dHB1dD4ge1xuICBjb25zdCBob3N0ID0gbmV3IE5vZGVKc1N5bmNIb3N0KCk7XG4gIGNvbnN0IHByb2plY3ROYW1lID0gY29udGV4dC50YXJnZXQgJiYgY29udGV4dC50YXJnZXQucHJvamVjdDtcbiAgaWYgKCFwcm9qZWN0TmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignVGhlIGJ1aWxkZXIgcmVxdWlyZXMgYSB0YXJnZXQuJyk7XG4gIH1cblxuICBjb25zdCByb290ID0gbm9ybWFsaXplKGNvbnRleHQud29ya3NwYWNlUm9vdCk7XG4gIGNvbnN0IHByb2plY3RNZXRhZGF0YSA9IGF3YWl0IGNvbnRleHQuZ2V0UHJvamVjdE1ldGFkYXRhKHByb2plY3ROYW1lKTtcbiAgY29uc3QgcHJvamVjdFJvb3QgPSByZXNvbHZlUGF0aChcbiAgICByb290LFxuICAgIG5vcm1hbGl6ZSgocHJvamVjdE1ldGFkYXRhLnJvb3QgYXMgc3RyaW5nKSB8fCAnJyksXG4gICk7XG5cbiAgLy8gVXNlcnMgY2FuIHNwZWNpZnkgYSBkaWZmZXJlbnQgYmFzZSBodG1sIGZpbGUgZS5nLiBcInNyYy9ob21lLmh0bWxcIlxuICBjb25zdCBpbmRleEZpbGUgPSBnZXRJbmRleE91dHB1dEZpbGUoYnJvd3Nlck9wdGlvbnMpO1xuICAvLyBXZSBuZWVkIHRvIHJlbmRlciB0aGUgcm91dGVzIGZvciBlYWNoIGxvY2FsZSBmcm9tIHRoZSBicm93c2VyIG91dHB1dC5cbiAgZm9yIChjb25zdCBvdXRwdXRQYXRoIG9mIGJyb3dzZXJSZXN1bHQub3V0cHV0UGF0aHMpIHtcbiAgICBjb25zdCBicm93c2VySW5kZXhJbnB1dFBhdGggPSBwYXRoLmpvaW4ob3V0cHV0UGF0aCwgaW5kZXhGaWxlKTtcbiAgICBjb25zdCBpbmRleEh0bWwgPSBmcy5yZWFkRmlsZVN5bmMoYnJvd3NlckluZGV4SW5wdXRQYXRoLCAndXRmOCcpO1xuXG4gICAgY29uc3QgeyBiYXNlT3V0cHV0UGF0aCA9ICcnIH0gPSBzZXJ2ZXJSZXN1bHQ7XG4gICAgY29uc3QgbG9jYWxlRGlyZWN0b3J5ID0gcGF0aC5yZWxhdGl2ZShicm93c2VyUmVzdWx0LmJhc2VPdXRwdXRQYXRoLCBvdXRwdXRQYXRoKTtcbiAgICBjb25zdCBzZXJ2ZXJCdW5kbGVQYXRoID0gcGF0aC5qb2luKGJhc2VPdXRwdXRQYXRoLCBsb2NhbGVEaXJlY3RvcnksICdtYWluLmpzJyk7XG4gICAgaWYgKCFmcy5leGlzdHNTeW5jKHNlcnZlckJ1bmRsZVBhdGgpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENvdWxkIG5vdCBmaW5kIHRoZSBtYWluIGJ1bmRsZTogJHtzZXJ2ZXJCdW5kbGVQYXRofWApO1xuICAgIH1cblxuICAgIGNvbnN0IHNoYXJkZWRSb3V0ZXMgPSBzaGFyZEFycmF5KHJvdXRlcywgbnVtUHJvY2Vzc2VzKTtcbiAgICBjb25zdCBzcGlubmVyID0gb3JhKGBQcmVyZW5kZXJpbmcgJHtyb3V0ZXMubGVuZ3RofSByb3V0ZShzKSB0byAke291dHB1dFBhdGh9Li4uYCkuc3RhcnQoKTtcblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCBfcGFyYWxsZWxSZW5kZXJSb3V0ZXMoXG4gICAgICAgIHNoYXJkZWRSb3V0ZXMsXG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIGluZGV4SHRtbCxcbiAgICAgICAgb3V0cHV0UGF0aCxcbiAgICAgICAgaW5kZXhGaWxlLFxuICAgICAgICBzZXJ2ZXJCdW5kbGVQYXRoLFxuICAgICAgKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgc3Bpbm5lci5mYWlsKGBQcmVyZW5kZXJpbmcgcm91dGVzIHRvICR7b3V0cHV0UGF0aH0gZmFpbGVkLmApO1xuXG4gICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IGVycm9yLm1lc3NhZ2UgfTtcbiAgICB9XG5cbiAgICBzcGlubmVyLnN1Y2NlZWQoYFByZXJlbmRlcmluZyByb3V0ZXMgdG8gJHtvdXRwdXRQYXRofSBjb21wbGV0ZS5gKTtcblxuICAgIGlmIChicm93c2VyT3B0aW9ucy5zZXJ2aWNlV29ya2VyKSB7XG4gICAgICBzcGlubmVyLnN0YXJ0KCdHZW5lcmF0aW5nIHNlcnZpY2Ugd29ya2VyLi4uJyk7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBhdWdtZW50QXBwV2l0aFNlcnZpY2VXb3JrZXIoXG4gICAgICAgICAgaG9zdCxcbiAgICAgICAgICByb290LFxuICAgICAgICAgIHByb2plY3RSb290LFxuICAgICAgICAgIG5vcm1hbGl6ZShvdXRwdXRQYXRoKSxcbiAgICAgICAgICBicm93c2VyT3B0aW9ucy5iYXNlSHJlZiB8fCAnLycsXG4gICAgICAgICAgYnJvd3Nlck9wdGlvbnMubmdzd0NvbmZpZ1BhdGgsXG4gICAgICAgICk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBzcGlubmVyLmZhaWwoJ1NlcnZpY2Ugd29ya2VyIGdlbmVyYXRpb24gZmFpbGVkLicpO1xuXG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogZXJyb3IubWVzc2FnZSB9O1xuICAgICAgfVxuXG4gICAgICBzcGlubmVyLnN1Y2NlZWQoJ1NlcnZpY2Ugd29ya2VyIGdlbmVyYXRpb24gY29tcGxldGUuJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJyb3dzZXJSZXN1bHQ7XG59XG5cbi8qKlxuICogQnVpbGRzIHRoZSBicm93c2VyIGFuZCBzZXJ2ZXIsIHRoZW4gcmVuZGVycyBlYWNoIHJvdXRlIGluIG9wdGlvbnMucm91dGVzXG4gKiBhbmQgd3JpdGVzIHRoZW0gdG8gcHJlcmVuZGVyLzxyb3V0ZT4vaW5kZXguaHRtbCBmb3IgZWFjaCBvdXRwdXQgcGF0aCBpblxuICogdGhlIGJyb3dzZXIgcmVzdWx0LlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZXhlY3V0ZShcbiAgb3B0aW9uczogUHJlcmVuZGVyQnVpbGRlck9wdGlvbnMsXG4gIGNvbnRleHQ6IEJ1aWxkZXJDb250ZXh0XG4pOiBQcm9taXNlPFByZXJlbmRlckJ1aWxkZXJPdXRwdXQ+IHtcbiAgY29uc3QgYnJvd3NlclRhcmdldCA9IHRhcmdldEZyb21UYXJnZXRTdHJpbmcob3B0aW9ucy5icm93c2VyVGFyZ2V0KTtcbiAgY29uc3QgYnJvd3Nlck9wdGlvbnMgPVxuICAgIGF3YWl0IGNvbnRleHQuZ2V0VGFyZ2V0T3B0aW9ucyhicm93c2VyVGFyZ2V0KSBhcyB1bmtub3duIGFzIEJyb3dzZXJCdWlsZGVyT3B0aW9ucztcbiAgY29uc3QgdHNDb25maWdQYXRoID1cbiAgICB0eXBlb2YgYnJvd3Nlck9wdGlvbnMudHNDb25maWcgPT09ICdzdHJpbmcnID8gYnJvd3Nlck9wdGlvbnMudHNDb25maWcgOiB1bmRlZmluZWQ7XG5cbiAgY29uc3Qgcm91dGVzID0gYXdhaXQgZ2V0Um91dGVzKG9wdGlvbnMsIHRzQ29uZmlnUGF0aCwgY29udGV4dCk7XG4gIGlmICghcm91dGVzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgYW55IHJvdXRlcyB0byBwcmVyZW5kZXIuYCk7XG4gIH1cblxuICBjb25zdCByZXN1bHQgPSBhd2FpdCBfc2NoZWR1bGVCdWlsZHMob3B0aW9ucywgY29udGV4dCk7XG4gIGNvbnN0IHsgc3VjY2VzcywgZXJyb3IsIGJyb3dzZXJSZXN1bHQsIHNlcnZlclJlc3VsdCB9ID0gcmVzdWx0O1xuICBpZiAoIXN1Y2Nlc3MgfHwgIWJyb3dzZXJSZXN1bHQgfHwgIXNlcnZlclJlc3VsdCkge1xuICAgIHJldHVybiB7IHN1Y2Nlc3MsIGVycm9yIH0gYXMgQnVpbGRlck91dHB1dDtcbiAgfVxuXG4gIHJldHVybiBfcmVuZGVyVW5pdmVyc2FsKFxuICAgIHJvdXRlcyxcbiAgICBjb250ZXh0LFxuICAgIGJyb3dzZXJSZXN1bHQsXG4gICAgc2VydmVyUmVzdWx0LFxuICAgIGJyb3dzZXJPcHRpb25zLFxuICAgIG9wdGlvbnMubnVtUHJvY2Vzc2VzLFxuICApO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjcmVhdGVCdWlsZGVyKGV4ZWN1dGUpO1xuIl19